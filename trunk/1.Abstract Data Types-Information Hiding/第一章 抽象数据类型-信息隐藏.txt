1．1数据类型

    数据类型是每种编程语言不可缺少的一部分。ANSI-C 有 int，double 和 char 这几种。程序员们很少满足于现状，而编程语言通常会提供了从预定义的类型创建新数据类型的机制。一种简单的方法是构造集合如数组，结构体和联合体。被C. A. R. Hoare称为“我们永远无法收回的一步”的指针，允许我们表示和操作本质上极其复杂的数据。
到底什么是数据类型？我们可以从几个方面来看。数据类型就是值（value）的集合——char就有256种不同的值，int就更多了；两者都有均匀的间隔，或多或少有点像是数学里的自然数或整数。double类型的值就更多了，但是它们实际上却不像数学里的实数。
    或者我们可以定义一种数据类型，它是一组值的集合以及作用于该集合之上的操作。一般来说，这些值是计算机能够表示的，而这些操作多少反映了可用的硬件指令。ANSI-C中的int在这方面上就做得不太好：值的集合在不同的机器上可能是不同的，并且如算数右移一样的操作也会不同。
    更加复杂的例子没有更好的用处。一般我们可以用结构体来定义线性表的元素。
        typedef struct node {
              struct node * next;
              ... information ...
        } node;
    至于对线性表的操作我们指定像这样的函数头部：
        node * head (node * elt, const node * tail);
    但是，这种办法是很松散的。好的编程原则要求我们封装数据项表示，并且只声明可能的操作。

1.2抽象数据类型

    如果我们不打算把具体表示暴露给用户，那么我们称这个数据类型是抽象的。理论上将这要求我们通过涉及到适当操作的数学公里来指定这个数据类型的属性。例如，只有当我们首先经常往一个队列里添加元素时我们才可以删除它，并且我们取回这个元素的书序与它们被加入的顺寻是相同的。
    抽象数据类型为程序员提供了巨大的灵活性。既然数据表示不是类型定义的一部分，我们可以自由的选择更加简单或者最有效的方法。如果我们正确区分了必要的信息（数据类型的内部信息），那么数据类型的使用与我们选择实现的方法就完全独立了。
    抽象数据类型满足了信息隐藏以及使用与实现分而治之的良好编程原则。信息（如数据项的表示）只要被提供给需要知道的它的人就可以了：是实现者而不是使用者。通过抽象数据类型我们可以清楚分开实现与使用：我们在把大系统分成小模块的道路上顺利前行。

1.3一个例子——Set

    那么我们怎么实现抽象数据类型呢？作为一个例子我们考虑一个带有add、find和drop操作的元素集合。它们适用于一个集合、一个元素，并且返回添加的、查找到的或者从集合中删除的元素。find可以被用来实现contain，它告诉我们这个集合中是否已经包含了这个元素。
    从这个角度，集合就是一种抽象数据类型。为了声明我们可以对一个集合做什么，我们创建了一个头文件Set.h
	#ifndef SET_H
    	#define SET_H
        extern const void * Set;
        void * add (void * set, const void * element);
        void * find (const void * set, const void * element);
        void * drop (void * set, const void * element);
        int contains (const void * set, const void * element);
        #endif
    预处理语句保护下面的声明：无论我们包含多少次Set.h，C编译器只会看到它一次。这种保护头文件的技术是非常标准的，GNU C编译器可以识别它并且当这个保护符号（宏SET_H）已经被定义了的时候不会再访问Set.h。
    Set.h是完整的，但是它有用么？我们几乎不能暴露或者显示更少的内容了：Set必须以某种方式来实现操作这个集合：add()获得一个元素并且将其添加进集合，返回该元素，无论这个元素是新加入的还是已经存在于集合中；find()在集合中查找一个元素，返回该元素或者空指针；drop()丁谓一个元素，从集合中将其删除，并且返回我们删除的元素；contains()把find()的结果转换成一个真值。
    不幸的是，remove是一个用来删除文件的ANSI-C库函数。如果我们使用其命名一个set的函数，我们就不能再包含stdio.h
我们一直使用通用指针void*。一方面它使得了解一个集合到底有什么内容变得不可能，但另一方面它允许我们向add()和其他的函数传递任何东西。并使任何东西都会表现的像一个集合或者一个元素——为了信息隐藏我们牺牲了类型安全。然而，我们将在第八章中看到如何才能使这种方式变得实现。

1.4内存管理

    我们可能已经忽略了一些事情：如何获得一个集合呢？Set是一个指针，不是一个使用typedef定义的类型；所以，我们不能定义一个Set类型的局部或者全局变量，而只能通过指针来指示集合和元素。并且我们在new.h中声明所有数据项的资源申请与释放的方法：
	void * new (const void * type, ...);
        void delete (void * item);
    就像Set.h一样，这个文件被预处理符号NEW_H保护。本文只显示了每个新文件中更有意义的部分。源文件软盘包含所有示例的完整代码。
    new()接受类似于Set一样的描述符以及更多的可能使用的初始化参数，它返回一个指向新创建的符合描述参数的数据项的指针。delete()接受一个有new()创建的指针并且回收相关资源。
    new()和delete()大体上是ANSI-C函数calloc()和free()的一个(向用户暴露的)前端函数。如果使用它们，描述符至少需要指明需要申请内存的大小。

1.5对象

    如果我们需要收集一个set中任何感兴趣的东西，我们就需要在头文件Object.h中描述另外一个抽象数据类型Object：
	extern const void * Object;               /* new(Object); */
        int differ (const void * a, const void * b);
    differ()能够比较对象：如果它们不相等就返回true，否则返回false。这样的描述为strcmp函数的应用留下空间：对于一些成对的对象我们可以选择返回正值或者负值来确定其次序。
    生活中的对象需要更多的功能来完成一些实际的事情。目前，我们把自己约束在成为一个集合中成员这样一个单纯的需求。如果我们创建一个更大的类库，我们会发现集合——事实上任何其他的东西——也是一个对象。在这点上，大量的实际情况也多少给予了我们自由。

1.6一个程序

    通过这些定义抽象数据类型的头文件，我们就可以写一个程序main.c
	#include <stdio.h>
        #include "new.h"
        #include "Object.h"
        #include "Set.h"
        int main ()
        {    void * s    =   new(Set);
             void * a    =   add(s, new(Object));
             void * b    =   add(s, new(Object));
             void * c    =   new(Object);
             if (contains(s, a) && contains(s, b))
                  puts("ok");
             if (contains(s, c))
                  puts("contains?");
             if (differ(a, add(s, a)))
                  puts("differ?");
             if (contains(s, drop(s, a)))
                  puts("drop?");
             delete(drop(s, b));
             delete(drop(s, c));
             return 0;
        }
    我们建立一个集合并且加入了两个新的对象。如果一切正常，我就能在集合中找到这两个对象，并且诶集合找不到其他的对象。这个程序应该简单的打印出ok。
    对于differ()的调用展示了一个语义：一个数学集合中只能包含一份对象a的拷贝；如果试图再加入一次就会返回原始对象并且differ()返回false。类似的，一旦我们删除了这个对象，它就不在这个集合中了。
    删除一个不在集合中的元素会产生一个空指针传递给delete()。目前我们坚持free()的语义并且它是可以接受空指针的。

1.7一个实现——Set

    main.c可以正确编译，但是我们在链接并且执行这个程序之前，我们必须实现这个抽象数据类型并且完成内存管理部分。如果一个对象不存放任何信息并且每个对象至多只属于一个集合，那么我们就可以把每个对象和集合都视为唯一的小整数，那么也就可以作为数组heap[]的索引。如果一个对象是一个集合的元素，那么该对象的数组元素中存储着其所在集合的整数索引值。这样，对象指向了包含它的集合。
    第一个方案是如此的简单以至于我们可以把所有的模块合到一个简单的文件Set.c中。集合和对象有相同的表示，所以new()不再考虑类型描述。它只返回一个heap[]中值为0的元素。
	#if ! defined MANY || MANY < 1
        #define MANY         10
        #endif
        static int heap [MANY];
        void * new (const void * type, ...)
        {     int * p;                                     /* & heap[1..] */
              for (p = heap + 1; p < heap + MANY; ++ p)
                   if (! * p)
                         break;
              assert(p < heap + MANY);
              * p = MANY;
              return p;
        }